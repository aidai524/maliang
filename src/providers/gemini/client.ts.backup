import { config } from '../../config/env';
import { ProviderError } from '../../utils/errors';
import { createLogger } from '../../utils/logger';
import { sleep } from '../../utils/sleep';
import type {
  GeminiGenerateOptions,
  GeminiSubmitResult,
  GeminiStatusResult,
  GeminiMode,
  GeminiResolution,
  GeminiAspectRatios,
  GenerationConfig,
  GeminiGenerateContentRequest,
} from './types';

const logger = createLogger('gemini');

const DEFAULT_API_BASE = 'https://generativelanguage.googleapis.com';
const DEFAULT_MODEL = 'gemini-3.0-pro-vision';

function buildGeminiRequest(
  prompt: string,
  inputImageUrl: string | undefined,
  mode: GeminiMode,
  resolution?: '1K' | '2K',
  aspectRatio?: GeminiAspectRatios,
  sampleCount?: number,
) {
  const generationConfig: GenerationConfig = {
    temperature: mode === 'draft' ? 0.7 : 1,
  };

  if (resolution) {
    generationConfig.imageConfig = {
      imageSize: resolution,
    };
  }

  if (aspectRatio) {
    if (!generationConfig.imageConfig) {
      generationConfig.imageConfig = {};
    }
    generationConfig.imageConfig.aspectRatio = aspectRatio;
  }

  if (sampleCount) {
    if (!generationConfig.imageConfig) {
      generationConfig.imageConfig = {};
    }
    generationConfig.imageConfig.numberOfImages = sampleCount;
  }

  const parts: any[] = [];

  if (sampleCount && sampleCount > 1) {
    for (let i = 0; i < sampleCount; i++) {
      parts.push({ text: prompt });
    }
  } else {
    parts.push({ text: prompt });
  }

  if (inputImageUrl) {
    parts.push({
      inlineData: {
        mimeType: 'image/png',
        data: inputImageUrl,
      },
    });
  }

  return {
    contents: [
      {
        role: 'user',
        parts,
      },
    ],
    generationConfig,
  };
}

export async function geminiSubmit(
  options: GeminiGenerateOptions
): Promise<GeminiSubmitResult> {
  const { apiKey, prompt, inputImageUrl, mode, resolution, aspectRatio, sampleCount } = options;

  const apiBase = config.gemini.apiBase || DEFAULT_API_BASE;
  const model = config.gemini.model || DEFAULT_MODEL;

  const requestBody = buildGeminiRequest(prompt, inputImageUrl, mode, resolution, aspectRatio, sampleCount);

  const url = `${apiBase}/v1beta/models/${model}:generateContent?key=${apiKey}`;

  logger.info('Submitting to Gemini API', {
    model,
    mode,
    hasInputImage: !!inputImageUrl,
    resolution,
    aspectRatio,
    sampleCount,
  });

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorText = await response.text();
      handleGeminiError(response.status, errorText);
    }

    const data = (await response.json()) as any;

    const requestId = `gemini_${Date.now()}_${Math.random().toString(36).slice(2)}`;

    await cacheGeminiResponse(requestId, data);

    logger.info('Gemini submit successful', { requestId });

    return { requestId };
  } catch (error) {
    if (error instanceof ProviderError) {
      throw error;
    }
    logger.error('Gemini submit failed', { error });
    throw new ProviderError(
      `Gemini submit failed ${error}`,
      'GEMINI_SUBMIT_ERROR'
    );
  }
}

export async function geminiPoll(
  requestId: string,
  apiKey: string
): Promise<GeminiStatusResult> {
  const cached = await getCachedGeminiResponse(requestId);

  if (cached) {
    return parseGeminiResponse(cached);
  }

  logger.warn('No cached response found', { requestId });

  return {
    status: 'FAILED',
    error: 'Response not found - may have expired',
  };
}

export async function geminiGenerate(
  options: GeminiGenerateOptions,
  pollOptions: {
    maxAttempts?: number;
    intervalMs?: number;
  } = {}
): Promise<GeminiStatusResult & { status: 'SUCCEEDED' | 'FAILED' }> {
  const { maxAttempts = 60, intervalMs = 3000 } = pollOptions;

  const { requestId } = await geminiSubmit(options);

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const result = await geminiPoll(requestId, options.apiKey);

    if (result.status === 'SUCCEEDED' || result.status === 'FAILED') {
      return result as any;
    }

    await sleep(intervalMs);
  }

  return {
    status: 'FAILED',
    error: 'Poll timeout',
  };
}

function handleGeminiError(status: number, errorText: string): never {
  let code = 'GEMINI_ERROR';
  let retryable = true;

  if (status === 400) {
    code = 'INVALID_REQUEST';
    retryable = false;
  } else if (status === 401) {
    code = 'INVALID_API_KEY';
    retryable = false;
  } else if (status === 429) {
    code = 'RATE_LIMIT_EXCEEDED';
    retryable = true;
  } else if (status >= 500) {
    code = 'SERVER_ERROR';
    retryable = true;
  }

  throw new ProviderError(
    `Gemini API error (${status}): ${errorText}`,
    code,
    retryable
  );
}

  const candidates = data.candidates || [];

  if (candidates.length === 0) {
    return {
      status: 'FAILED',
      error: 'No candidates in response',
    };
  }

  const candidate = candidates[0];
  const content = candidate.content || {};
  const images = Array<{ url: string; mimeType: string }> = [];

  // Images are in metadata.images array
  const metadataImages = content.metadata?.images || [];
  for (const metadataImage of metadataImages) {
    images.push({
      url: `data:${metadataImage.mimeType};base64,${metadataImage.data}`,
      mimeType: metadataImage.mimeType,
    });
  }

  if (images.length === 0) {
    return {
      status: 'FAILED',
      error: 'No images generated',
    };
  }

  return {
    status: 'SUCCEEDED',
    images,
  };
}

  const candidates = data.candidates || [];

  if (candidates.length === 0) {
    return {
      status: 'FAILED',
      error: 'No candidates in response',
    };
  }

  const candidate = candidates[0];
  const metadata = candidate.metadata || {};
  const images: Array<{ url: string; mimeType: string }> = [];

  // Images are in metadata.images array
  const imageList = metadata.images || [];
  for (const image of imageList) {
    images.push({
      url: `data:${image.mimeType};base64,${image.data}`,
      mimeType: image.mimeType,
    });
  }

  if (images.length === 0) {
    return {
      status: 'FAILED',
      error: 'No images generated',
    };
  }

  return {
    status: 'SUCCEEDED',
    images,
  };
}

  const candidates = data.candidates || [];
  
  if (candidates.length === 0) {
    return {
      status: 'FAILED',
      error: 'No candidates in response',
    };
  }
  
  const candidate = candidates[0];
  const content = candidate.content || {};
  const parts = content.parts || [];
  const images: Array<{ url: string; mimeType: string }> = [];
  
  // Images are in metadata.images array
  const metadataImages = content.metadata?.images || [];
  for (const metadataImage of metadataImages) {
    images.push({
      url: `data:${metadataImage.mimeType};base64,${metadataImage.data}`,
      mimeType: metadataImage.mimeType,
    });
  }
  
  if (images.length === 0) {
    return {
      status: 'FAILED',
      error: 'No images generated',
    };
  }
  
  return {
    status: 'SUCCEEDED',
    images,
  };
}

const responseCache = new Map<string, any>();

async function cacheGeminiResponse(requestId: string, data: any): Promise<void> {
  responseCache.set(requestId, data);

  setTimeout(() => {
    responseCache.delete(requestId);
  }, 5 * 60 * 1000);
}

async function getCachedGeminiResponse(requestId: string): Promise<any | null> {
  return responseCache.get(requestId) || null;
}
